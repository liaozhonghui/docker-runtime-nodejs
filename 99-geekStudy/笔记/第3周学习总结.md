### 学习总结

#### 二叉树、满二叉树、完全二叉树、二叉搜索树

1. 满二叉树：除了叶子节点之外，每个节点都有左右两个子节点
2. 完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大
3. 二叉搜索树：则左子树上所有结点的值均小于它的根结点的值,且右子树上所有结点的值均大于它的根结点的值
4. 树的遍历递归代码
```C++
// 先序遍历
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
// 中序遍历
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
// 后序遍历
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```
5. 二叉树遍历的时间复杂度为O(n)

#### 堆与二叉堆

1. 大顶堆与小顶堆
2. 时间复杂度：
    - 建堆的时间复杂度为O(n)
    - 排序的时间复杂度为O(nlogn)
    - 插入，删除时间复杂度均为O(logn)
3. 二叉堆（使用完全二叉树进行实现）
4. 应用场景：
    - topK问题
    - 实现优先队列
    - 热点数据问题
    - 高性能定时器
    - 求解中位数
    - 求解top百分比数据

5. 解析求百分比K的问题
    - 即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据


#### 图的属性
1. 图定义（节点，边，有向图，无向图）
2. 表示方式（邻接矩阵，邻接表）
3. 邻接表优化：
链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边

#### 递归的时间复杂度分析
1. 递归树层层分析

#### 分治和回溯
1. 有序度和逆序对
2. 递归求解